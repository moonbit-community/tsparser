// Generated using `moon info`, DON'T EDIT IT
package "moonbit-community/tsparser"

import {
  "moonbitlang/core/debug",
}

// Values
pub fn parse_program(String, name? : String) -> (ArrayView[ParseError], Program)

pub fn parse_program_with_jsx(String, Bool, name? : String) -> (ArrayView[ParseError], Program)

// Errors
pub(all) suberror LexError {
  InvalidChar(pos~ : Position, UInt16)
  UnterminatedString(pos~ : Position)
  UnexpectedEndOfText(pos~ : Position)
  UnterminatedComment(pos~ : Position)
  InvalidNumber(pos~ : Position, String)
}
pub impl Eq for LexError
pub impl @debug.Debug for LexError

pub(all) suberror ParseError {
  LexErr(LexError)
  UnexpectedEof(pos~ : Position)
  UnexpectedToken(pos~ : Position, String)
  Expected(pos~ : Position, String)
  Diagnostic(filename~ : String, line~ : Int, column~ : Int, error_code~ : Int, error_msg~ : String)
}
pub impl Eq for ParseError
pub impl Show for ParseError
pub impl @debug.Debug for ParseError

// Types and methods
pub enum AccessModifier {
  Public
  Private
  Protected
}
pub impl @debug.Debug for AccessModifier

pub enum ArrayElement {
  Expr(Expr)
  Spread(Expr)
  Hole
}
pub impl @debug.Debug for ArrayElement

pub struct ArrayPattern {
  elems : Array[ArrayPatternElem]
}
pub impl @debug.Debug for ArrayPattern

pub enum ArrayPatternElem {
  Elem(BindingElement)
  Rest(BindingPattern)
  Hole
}
pub impl @debug.Debug for ArrayPatternElem

pub struct ArrowFunction {
  type_params : Array[TypeParam]
  params : Array[Param]
  return_type : TypeNode?
  body : FunctionBody
}
pub impl @debug.Debug for ArrowFunction

pub struct AssignExpr {
  op : AssignOp
  target : Expr
  value : Expr
}
pub impl @debug.Debug for AssignExpr

pub enum AssignOp {
  Assign
  AddAssign
  SubAssign
  MulAssign
  DivAssign
  ModAssign
  BitAndAssign
  BitOrAssign
  BitXorAssign
  ShlAssign
  ShrAssign
  UShrAssign
}
pub impl @debug.Debug for AssignOp

pub struct BinaryExpr {
  op : BinaryOp
  left : Expr
  right : Expr
}
pub impl @debug.Debug for BinaryExpr

pub enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Mod
  Eq
  Neq
  StrictEq
  StrictNeq
  Lt
  Lte
  Gt
  Gte
  Instanceof
  In
  And
  Or
  Nullish
  BitAnd
  BitOr
  BitXor
  Shl
  Shr
  UShr
  Comma
  Pow
}
pub impl @debug.Debug for BinaryOp

pub struct BindingElement {
  pattern : BindingPattern
  default_value : Expr?
  span : Span
}
pub impl @debug.Debug for BindingElement

pub struct BindingPattern {
  kind : BindingPatternKind
  span : Span
}
pub impl @debug.Debug for BindingPattern

pub enum BindingPatternKind {
  Ident(String)
  Object(ObjectPattern)
  Array(ArrayPattern)
}
pub impl @debug.Debug for BindingPatternKind

pub struct Block {
  stmts : Array[Stmt]
  span : Span
}
pub impl @debug.Debug for Block

pub struct CallExpr {
  callee : Expr
  args : Array[Expr]
  optional : Bool
}
pub impl @debug.Debug for CallExpr

pub struct CatchClause {
  param : CatchParam?
  body : Block
}
pub impl @debug.Debug for CatchClause

pub struct CatchParam {
  name : String
  type_ann : TypeNode?
  span : Span
}
pub impl @debug.Debug for CatchParam

pub struct ClassDecl {
  name : String?
  type_params : Array[TypeParam]
  extends : Expr?
  implements : Array[TypeNode]
  members : Array[ClassMember]
  span : Span
}
pub impl @debug.Debug for ClassDecl

pub struct ClassMember {
  kind : ClassMemberKind
  is_static : Bool
  access : AccessModifier?
  is_readonly : Bool
  span : Span
}
pub impl @debug.Debug for ClassMember

pub enum ClassMemberKind {
  Constructor(Array[Param], Block)
  Method(String, Array[Param], TypeNode?, Block)
  Getter(String, TypeNode?, Block)
  Setter(String, Param, Block)
  Field(String, TypeNode?, Expr?)
}
pub impl @debug.Debug for ClassMemberKind

pub struct ConditionalExpr {
  condition : Expr
  consequent : Expr
  alternate : Expr
}
pub impl @debug.Debug for ConditionalExpr

pub struct DoWhileStmt {
  body : Stmt
  condition : Expr
}
pub impl @debug.Debug for DoWhileStmt

pub struct EnumDecl {
  name : String
  members : Array[EnumMember]
  is_const : Bool
  span : Span
}
pub impl @debug.Debug for EnumDecl

pub struct EnumMember {
  name : String
  init : Expr?
  span : Span
}
pub impl @debug.Debug for EnumMember

pub enum ExportDecl {
  Named(ExportNamed)
  Default(ExportDefault)
  Declaration(Stmt)
  Assign(Expr)
}
pub impl @debug.Debug for ExportDecl

pub enum ExportDefault {
  Expr(Expr)
  Function(FunctionDecl)
  Class(ClassDecl)
}
pub impl @debug.Debug for ExportDefault

pub struct ExportNamed {
  is_type_only : Bool
  specs : Array[ExportSpec]
  from : String?
}
pub impl @debug.Debug for ExportNamed

pub struct ExportSpec {
  is_type_only : Bool
  name : String
  as_name : String?
  span : Span
}
pub impl @debug.Debug for ExportSpec

pub struct Expr {
  kind : ExprKind
  span : Span
}
pub impl @debug.Debug for Expr

pub enum ExprKind {
  Ident(String)
  Number(String)
  String(String)
  Bool(Bool)
  Null
  Undefined
  This
  Array(Array[ArrayElement])
  Object(ObjectLiteral)
  Function(FunctionDecl)
  Class(ClassDecl)
  Arrow(ArrowFunction)
  New(NewExpr)
  TypeAssert(TypeAssert)
  Template(TemplateLiteral)
  Unary(UnaryExpr)
  Update(UpdateExpr)
  NonNull(Expr)
  Binary(BinaryExpr)
  Conditional(ConditionalExpr)
  Assign(AssignExpr)
  Call(CallExpr)
  Member(MemberExpr)
}
pub impl @debug.Debug for ExprKind

pub enum ForInLeft {
  Var(VarDecl)
  Expr(Expr)
}
pub impl @debug.Debug for ForInLeft

pub struct ForInStmt {
  left : ForInLeft
  right : Expr
  body : Stmt
}
pub impl @debug.Debug for ForInStmt

pub enum ForInit {
  Var(VarDecl)
  Expr(Expr)
}
pub impl @debug.Debug for ForInit

pub struct ForOfStmt {
  left : ForInLeft
  right : Expr
  body : Stmt
}
pub impl @debug.Debug for ForOfStmt

pub struct ForStmt {
  init : ForInit?
  condition : Expr?
  update : Expr?
  body : Stmt
}
pub impl @debug.Debug for ForStmt

pub enum FunctionBody {
  Block(Block)
  Expr(Expr)
}
pub impl @debug.Debug for FunctionBody

pub struct FunctionDecl {
  name : String?
  type_params : Array[TypeParam]
  params : Array[Param]
  return_type : TypeNode?
  body : Block
}
pub impl @debug.Debug for FunctionDecl

pub struct ImportAssignDecl {
  name : String
  value : Expr
  span : Span
}
pub impl @debug.Debug for ImportAssignDecl

pub struct ImportDecl {
  is_type_only : Bool
  default_name : String?
  ns_name : String?
  named : Array[ImportSpec]
  from : String
  span : Span
}
pub impl @debug.Debug for ImportDecl

pub struct ImportSpec {
  is_type_only : Bool
  name : String
  as_name : String?
  span : Span
}
pub impl @debug.Debug for ImportSpec

pub struct InterfaceDecl {
  name : String
  type_params : Array[TypeParam]
  extends : Array[TypeNode]
  members : Array[InterfaceMember]
  span : Span
}
pub impl @debug.Debug for InterfaceDecl

pub struct InterfaceMember {
  name : String
  optional : Bool
  type_ann : TypeNode
  span : Span
}
pub impl @debug.Debug for InterfaceMember

pub enum Keyword {
  Let
  Const
  Var
  Function
  Return
  If
  Else
  While
  For
  Do
  Switch
  Case
  Type
  Typeof
  Interface
  Enum
  True
  False
  Null
  Undefined
  This
  Delete
  Void
  Await
  Yield
  New
  Class
  Extends
  Implements
  Export
  Import
  From
  As
  Default
  Abstract
  Public
  Private
  Protected
  Readonly
  Static
  Get
  Set
  Break
  Continue
  Try
  Catch
  Finally
  Throw
}
pub impl Eq for Keyword
pub impl @debug.Debug for Keyword

pub struct LabeledStmt {
  label : String
  stmt : Stmt
}
pub impl @debug.Debug for LabeledStmt

pub struct MemberExpr {
  object : Expr
  property : MemberProp
  computed : Bool
  optional : Bool
}
pub impl @debug.Debug for MemberExpr

pub enum MemberProp {
  Ident(String)
  Expr(Expr)
}
pub impl @debug.Debug for MemberProp

pub struct NamespaceDecl {
  name : String
  body : Block
  span : Span
}
pub impl @debug.Debug for NamespaceDecl

pub struct NewExpr {
  callee : Expr
  args : Array[Expr]
}
pub impl @debug.Debug for NewExpr

pub struct ObjectLiteral {
  props : Array[ObjectProp]
}
pub impl @debug.Debug for ObjectLiteral

pub struct ObjectPattern {
  props : Array[ObjectPatternProp]
}
pub impl @debug.Debug for ObjectPattern

pub enum ObjectPatternProp {
  Property(ObjectPatternProperty)
  Rest(BindingPattern)
}
pub impl @debug.Debug for ObjectPatternProp

pub struct ObjectPatternProperty {
  key : String
  binding : BindingElement
  shorthand : Bool
  span : Span
}
pub impl @debug.Debug for ObjectPatternProperty

pub enum ObjectProp {
  Property(ObjectPropEntry)
  Spread(Expr)
}
pub impl @debug.Debug for ObjectProp

pub struct ObjectPropEntry {
  name : String
  value : Expr
  shorthand : Bool
  span : Span
}
pub impl @debug.Debug for ObjectPropEntry

pub struct Param {
  pattern : BindingPattern
  optional : Bool
  type_ann : TypeNode?
  default_value : Expr?
  is_rest : Bool
  span : Span
}
pub impl @debug.Debug for Param

pub struct Position {
  offset : Int
  line : Int
  column : Int
}
pub impl Eq for Position
pub impl @debug.Debug for Position

pub struct Program {
  stmts : Array[Stmt]
}
pub impl @debug.Debug for Program

pub struct Span {
  start : Position
  end : Position
}
pub fn Span::merge(Self, Self) -> Self
pub impl Eq for Span
pub impl @debug.Debug for Span

pub struct Stmt {
  kind : StmtKind
  span : Span
}
pub impl @debug.Debug for Stmt

pub enum StmtKind {
  ImportDecl(ImportDecl)
  ImportAssign(ImportAssignDecl)
  ExportDecl(ExportDecl)
  VarDecl(VarDecl)
  FunctionDecl(FunctionDecl)
  ClassDecl(ClassDecl)
  NamespaceDecl(NamespaceDecl)
  TypeAliasDecl(TypeAliasDecl)
  InterfaceDecl(InterfaceDecl)
  EnumDecl(EnumDecl)
  Return(Expr?)
  If(Expr, Stmt, Stmt?)
  While(Expr, Stmt)
  For(ForStmt)
  ForIn(ForInStmt)
  ForOf(ForOfStmt)
  DoWhile(DoWhileStmt)
  Switch(SwitchStmt)
  Break(String?)
  Continue(String?)
  Throw(Expr)
  Try(TryStmt)
  Labeled(LabeledStmt)
  ExprStmt(Expr)
  Block(Block)
  Empty
}
pub impl @debug.Debug for StmtKind

pub struct SwitchCase {
  case_expr : Expr?
  consequent : Array[Stmt]
}
pub impl @debug.Debug for SwitchCase

pub struct SwitchStmt {
  discriminant : Expr
  cases : Array[SwitchCase]
}
pub impl @debug.Debug for SwitchStmt

pub struct TemplateLiteral {
  quasis : Array[String]
  exprs : Array[Expr]
}
pub impl @debug.Debug for TemplateLiteral

pub struct Token {
  kind : TokenKind
  span : Span
}
pub impl Eq for Token
pub impl @debug.Debug for Token

pub enum TokenKind {
  Ident(String)
  Number(String)
  String(String)
  Keyword(Keyword)
  LParen
  RParen
  LBrace
  RBrace
  LBracket
  RBracket
  Comma
  Semicolon
  Colon
  Dot
  At
  Question
  QuestionDot
  Nullish
  Arrow
  Plus
  PlusPlus
  PlusEq
  Minus
  MinusMinus
  MinusEq
  Star
  StarStar
  StarEq
  Slash
  SlashEq
  Percent
  PercentEq
  Ellipsis
  TemplateStart
  TemplateChunk(String)
  TemplateExprStart
  TemplateEnd
  Eq
  EqEq
  EqEqEq
  NotEq
  NotEqEq
  Lt
  Lte
  Gt
  Gte
  AndAnd
  OrOr
  Ampersand
  Pipe
  Caret
  Bang
  Tilde
  Eof
}
pub impl Eq for TokenKind
pub impl @debug.Debug for TokenKind

pub struct TryStmt {
  block : Block
  handler : CatchClause?
  finalizer : Block?
}
pub impl @debug.Debug for TryStmt

pub struct TypeAliasDecl {
  name : String
  type_params : Array[TypeParam]
  value : TypeNode
  span : Span
}
pub impl @debug.Debug for TypeAliasDecl

pub struct TypeAssert {
  expr : Expr
  type_ann : TypeNode
}
pub impl @debug.Debug for TypeAssert

pub enum TypeKind {
  Ident(String)
  TypeQuery(String)
  Literal(TypeLiteral)
  Tuple(Array[TypeNode])
  Object(Array[TypeMember])
  Union(Array[TypeNode])
  Intersection(Array[TypeNode])
  Conditional(TypeNode, TypeNode, TypeNode, TypeNode)
  TypeOperator(String, TypeNode)
  TypePredicate(String, TypeNode)
  Array(TypeNode)
  IndexAccess(TypeNode, TypeNode)
  Generic(TypeNode, Array[TypeNode])
  Function(Array[TypeNode], TypeNode)
}
pub impl @debug.Debug for TypeKind

pub enum TypeLiteral {
  String(String)
  Number(String)
  Bool(Bool)
  Null
  Undefined
}
pub impl @debug.Debug for TypeLiteral

pub struct TypeMember {
  name : String
  optional : Bool
  type_ann : TypeNode
  span : Span
}
pub impl @debug.Debug for TypeMember

pub struct TypeNode {
  kind : TypeKind
  span : Span
}
pub impl @debug.Debug for TypeNode

pub struct TypeParam {
  name : String
  constraint : TypeNode?
  default_type : TypeNode?
  span : Span
}
pub impl @debug.Debug for TypeParam

pub struct UnaryExpr {
  op : UnaryOp
  expr : Expr
}
pub impl @debug.Debug for UnaryExpr

pub enum UnaryOp {
  Plus
  Minus
  Not
  BitNot
  Typeof
  Delete
  Void
  Await
  Yield
  YieldStar
}
pub impl @debug.Debug for UnaryOp

pub struct UpdateExpr {
  op : UpdateOp
  prefix : Bool
  expr : Expr
}
pub impl @debug.Debug for UpdateExpr

pub enum UpdateOp {
  Increment
  Decrement
}
pub impl @debug.Debug for UpdateOp

pub struct VarDecl {
  kind : VarKind
  decls : Array[VarDeclarator]
}
pub impl @debug.Debug for VarDecl

pub struct VarDeclarator {
  pattern : BindingPattern
  type_ann : TypeNode?
  init : Expr?
  span : Span
}
pub impl @debug.Debug for VarDeclarator

pub enum VarKind {
  Let
  Const
  Var
}
pub impl @debug.Debug for VarKind

// Type aliases

// Traits

